//!
//! Common functionality used by other Training Assistant systems.
//! 
use clap::{Command, ArgMatches};
use std::result;
use std::ffi::OsString;

mod db;
use db::DatabaseConnection;
use db::TableConfig;
use db::RowType;

pub struct Context {
    plugins: Vec<Box<dyn Plugin>>,
    commands: Vec<(Command, ProcessCommandFn)>,
    tables: Vec<TableConfig>,
}

impl Context {
    pub fn add_command(&mut self, command: Command, process_command_fn: ProcessCommandFn) -> &mut Self {
        self.commands.push((command, process_command_fn));
        self
    }

    pub fn new() -> Self {
        Self {
            plugins: Vec::default(),
            commands: Vec::default(),
            tables: Vec::default(),
        }
    }

    pub fn add_plugin<P>(&mut self, plugin: P) -> &mut Self
        where P: Plugin + Clone + 'static
    {
        self.plugins.push(Box::new(plugin.clone()));
        plugin.build(self);

        self
    }

    pub fn commands(&self) -> &Vec<(Command, ProcessCommandFn)> {
        &self.commands
    }

    pub fn add_table<R>(&mut self, table_name: String) -> &mut Self
        where R: RowType
    {
        self.tables.push(TableConfig {
            table_name,
            setup_fn: R::setup
        });

        self 
    }

    pub fn open_db_connection(&self) -> Result<DatabaseConnection> {
        DatabaseConnection::open_default(&self.tables)
    }

    pub fn execute(&self, command_str: &str) -> Result<CommandResponse> {
        let mut command = Command::new("tacl")
            .version("0.1.0")
            .about("Command line interface for Training Assistant")
            .subcommand_required(true);

        for (c, _) in self.commands() {
            command = command.subcommand(c);
        }

        let cmd_string = shlex::split(format!("tacl {}", command_str).as_str()).unwrap().iter().map(OsString::from).collect::<Vec<_>>();

        let matches = command.get_matches_from(cmd_string);

        let mut database_connection = self.open_db_connection()?;

        if let Some(subcommand_name) = matches.subcommand_name() {
            for (c, f) in self.commands() {
                if c.get_name() == subcommand_name
                    && let Some(subcommand_matches) = matches.subcommand_matches(subcommand_name)
                {
                    let response = f(subcommand_matches, &mut database_connection)?;
                    return Ok(response);
                }
            }
        }
        Err(Error::UnknownError)
    }
}

impl Default for Context {
    fn default() -> Self {
        Self::new()
    }
}

/// The result of running a successful command.
#[derive(Default)]
pub struct CommandResponse {
    text: Option<String>
}

impl CommandResponse {
    pub fn new(text: &str) -> Self {
        Self {
            text: Some(text.into())
        }
    }

    pub fn text(&self) -> &Option<String> {
        &self.text
    }
}

pub type ProcessCommandFn = fn(&ArgMatches, &mut DatabaseConnection) -> Result<CommandResponse>;

/// An interface for adding functionality to a Context. Inspired by Bevy's plugin interface.
pub trait Plugin {

    /// Runs on adding the plugin to a Context. Use this to register commands, add tables, etc.
    fn build(self, context: &mut Context) -> ();
}

/// Various types of errors that can be generated by a `Context`.
#[derive(Debug)]
pub enum Error {
   FileError(String),
   DatabaseError(String),
   NoConnectionError,
   UnknownError
}

pub type Result<T, E = Error> = result::Result<T, E>; 

impl From<rusqlite::Error> for Error {
    fn from(e: rusqlite::Error) -> Self {
        Error::DatabaseError(e.to_string())
    }
}

pub mod prelude {
    pub use {
        crate::{
            Context,
            Plugin,
            Error,
            Result,
            CommandResponse,
            db::{
                DbPlugin,
                DatabaseConnection,
                RowId,
                RowType,
                FieldType,
                Trainer,
                Client,
                TableConfig
            }
        }
    };
}

#[cfg(test)]
mod test {
    use crate::*;
    use std::sync::atomic::{AtomicUsize, Ordering};

    #[derive(Default, Clone)]
    struct TestPlugin;

    impl Plugin for TestPlugin {
        fn build(self, context: &mut Context) {
            context.add_command(Command::new("test"), process_test_command);
            context.add_command(Command::new("test2"), process_test2_command);
        }
    }

    static COMMAND_EXECUTED_COUNTER: AtomicUsize = AtomicUsize::new(0);
    
    fn process_test_command(_arg_matches: &ArgMatches, _db_connection: &mut DatabaseConnection) -> Result<CommandResponse> {
        COMMAND_EXECUTED_COUNTER.store(1, Ordering::Relaxed);
        Ok(CommandResponse::default())
    }

    static COMMAND2_EXECUTED_COUNTER: AtomicUsize = AtomicUsize::new(0);

    fn process_test2_command(_arg_matches: &ArgMatches, _db_connection: &mut DatabaseConnection) -> Result<CommandResponse> {
        COMMAND2_EXECUTED_COUNTER.store(1, Ordering::Relaxed);
        Ok(CommandResponse::new("foobar"))
    }

    #[test]
    fn plugin_with_commands_test() -> Result<()> {
        let mut context = Context::new();
        context.add_plugin::<TestPlugin>(TestPlugin::default());
        assert_eq!(context.commands().len(), 2);
        let response = context.execute("test")?;
        assert_eq!(COMMAND_EXECUTED_COUNTER.load(Ordering::Relaxed), 1);
        assert!(response.text().is_none());
        let response2 = context.execute("test2")?;
        assert_eq!(COMMAND2_EXECUTED_COUNTER.load(Ordering::Relaxed), 1);
        assert!(response2.text().is_some());
        assert_eq!(response2.text().clone().unwrap(), "foobar");
        Ok(())
    }
}

